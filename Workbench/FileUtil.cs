namespace Workbench;

internal static class FileUtil
{
    public static readonly string[] HEADER_FILES = new string[] { "", ".h", ".hpp", ".hxx" };
    public static readonly string[] SOURCE_FILES = new string[] { ".cc", ".cpp", ".cxx", ".inl" };

    public static bool FileHasAnyExtension(string filePath, string[] extensions)
    {
        var ext = Path.GetExtension(filePath);
        return extensions.Contains(ext);
    }

    public static IEnumerable<string> ListFilesRecursivly(string path, string[] extensions)
    {
        foreach (var f in Directory.EnumerateFiles(path, "*", SearchOption.AllDirectories))
        {
            bool x = Workbench.FileUtil.FileHasAnyExtension(f, extensions);
            if (x)
            {
                yield return f;
            }
        }
    }

    public static string GetFirstFolder(string root, string file)
    {
        var rel = Path.GetRelativePath(root, file);
        var cat = rel.Split(Path.DirectorySeparatorChar, 2)[0];
        return cat;
    }

    public static IEnumerable<FileInfo> IterateFiles(DirectoryInfo root, bool includeHidden, bool recursive)
    {
        var searchOptions = new EnumerationOptions
        {
            AttributesToSkip = includeHidden
                ? FileAttributes.Hidden | FileAttributes.System
                : FileAttributes.System
        };

        foreach(var f in SubIterateFiles(root, searchOptions, recursive))
        {
            yield return f;
        }

        static IEnumerable<FileInfo> SubIterateFiles(DirectoryInfo root, EnumerationOptions searchOptions, bool includeDirectories)
        {
            foreach (var f in root.GetFiles("*", searchOptions))
            {
                yield return f;
            }

            if (includeDirectories)
            {
                foreach (var d in root.GetDirectories("*", searchOptions))
                {
                    if (IsValidDirectory(d) == false) { continue; }
                    foreach (var f in SubIterateFiles(d, searchOptions, true))
                    {
                        yield return f;
                    }
                }
            }
        }
    }

    public static string? ClassifySourceOrNull(FileInfo f)
    {
        switch (f.Extension)
        {
            case ".cs":
                return "c#";

            case ".jsx":
                return "React";

            case ".ts":
            case ".js":
                return "Javascript/typescript";

            case ".cpp":
            case ".c":
            case ".h":
            case ".hpp":
                return "C/C++";

            default:
                return null;
        }
    }

    public static bool LooksAutoGenerated(IEnumerable<string> lines)
    {
        return lines
                    .Take(5)
                    .Select(x => LineLooksLikeAutoGenerated(x))
                    .Where(x => x)
                    .FirstOrDefault(false);
    }

    private static bool LineLooksLikeAutoGenerated(string line)
    {
        var lower = line.ToLowerInvariant();
        if (lower.Contains("auto-generated"))
        {
            return true;
        }

        if (lower.Contains("generated by"))
        {
            return true;
        }

        return false;
    }

    static private bool IsValidDirectory(DirectoryInfo d)
    {
        return d.Name switch
        {
            ".git" => false,
            "node_modules" => false,
            _ => true,
        };
    }
}