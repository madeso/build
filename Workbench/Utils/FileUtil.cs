namespace Workbench.Utils;

internal static class FileUtil
{
    public static readonly string[] HEADER_FILES = new string[] { "", ".h", ".hpp", ".hxx" };
    public static readonly string[] SOURCE_FILES = new string[] { ".cc", ".cpp", ".cxx", ".inl" };
    public static readonly string[] HEADER_AND_SOURCE_FILES = SOURCE_FILES.Concat(HEADER_FILES).ToArray();

    public static readonly string[] PITCHFORK_FOLDERS = new string[] { "apps", "libs", "src", "include" };

    public static bool IsTranslationUnitExtension(string ext)
    {
        return ext switch
        {
            ".cpp" or ".c" or ".cc" or ".cxx" or ".mm" or ".m" => true,
            _ => false,
        };
    }

    internal static bool IsSource(string path)
    {
        return Path.GetExtension(path) switch
        {
            ".cc" or ".cpp" or ".c" => true,
            _ => false
        };
    }

    internal static bool is_header(string path)
    {
        return Path.GetExtension(path) switch
        {
            "" => true,
            ".h" => true,
            ".hpp" => true,
            _ => false
        };
    }

    public static bool IsTranslationUnit(string path)
    {
        return IsTranslationUnitExtension(Path.GetExtension(path));
    }

    public static bool FileHasAnyExtension(string filePath, string[] extensions)
    {
        var ext = Path.GetExtension(filePath);
        return extensions.Contains(ext);
    }

    public static IEnumerable<string> ListFilesRecursivly(string path, string[] extensions)
    {
        if (File.Exists(path))
        {
            yield return path;
        }
        else
        {
            foreach (var f in Directory.EnumerateFiles(path, "*", SearchOption.AllDirectories))
            {
                bool x = extensions.Length == 0 || FileHasAnyExtension(f, extensions);
                if (x)
                {
                    yield return f;
                }
            }
        }
    }

    private static IEnumerable<string> list_files_in_dir(string dir)
    {
        return ListFilesRecursivly(dir, HEADER_AND_SOURCE_FILES)
            .Where(x => new FileInfo(x).Name.StartsWith("pch.") == false);
    }

    public static IEnumerable<string> list_all_files(string root)
    {
        IEnumerable<string> Files(string relativeDir)
        {
            var dir = new DirectoryInfo(Path.Join(root, relativeDir)).FullName;
            if (Directory.Exists(dir) == false)
            {
                yield break;
            }
            foreach (var f in list_files_in_dir(dir))
            {
                yield return f;
            }
        }

        return PITCHFORK_FOLDERS
            .Select(Files)
            .Aggregate((a, b) => a.Concat(b));
    }

    public static string GetFirstFolder(string root, string file)
    {
        var rel = Path.GetRelativePath(root, file);
        var cat = rel.Split(Path.DirectorySeparatorChar, 2)[0];
        return cat;
    }

    public static IEnumerable<FileInfo> IterateFiles(DirectoryInfo root, bool includeHidden, bool recursive)
    {
        var searchOptions = new EnumerationOptions
        {
            AttributesToSkip = includeHidden
                ? FileAttributes.Hidden | FileAttributes.System
                : FileAttributes.System
        };

        foreach (var f in SubIterateFiles(root, searchOptions, recursive))
        {
            yield return f;
        }

        static IEnumerable<FileInfo> SubIterateFiles(DirectoryInfo root, EnumerationOptions searchOptions, bool includeDirectories)
        {
            foreach (var f in root.GetFiles("*", searchOptions))
            {
                yield return f;
            }

            if (includeDirectories)
            {
                foreach (var d in root.GetDirectories("*", searchOptions))
                {
                    if (IsValidDirectory(d) == false) { continue; }
                    foreach (var f in SubIterateFiles(d, searchOptions, true))
                    {
                        yield return f;
                    }
                }
            }
        }
    }

    public static string? ClassifySourceOrNull(FileInfo f)
    {
        return f.Extension switch
        {
            ".cs" => "c#",
            ".jsx" => "React",
            ".ts" or ".js" => "Javascript/typescript",
            ".cpp" or ".c" or ".h" or ".hpp" => "C/C++",
            _ => null,
        };
    }

    public static bool LooksAutoGenerated(IEnumerable<string> lines)
    {
        return lines
                    .Take(5)
                    .Select(x => LineLooksLikeAutoGenerated(x))
                    .Where(x => x)
                    .FirstOrDefault(false);
    }

    private static bool LineLooksLikeAutoGenerated(string line)
    {
        var lower = line.ToLowerInvariant();
        if (lower.Contains("auto-generated"))
        {
            return true;
        }

        if (lower.Contains("generated by"))
        {
            return true;
        }

        return false;
    }

    private static bool IsValidDirectory(DirectoryInfo d)
    {
        return d.Name switch
        {
            ".git" => false,
            "node_modules" => false,
            _ => true,
        };
    }

    internal static string RealPath(string rel)
    {
        var dir = new DirectoryInfo(rel);
        if (dir.Exists) { return dir.FullName; }

        var file = new FileInfo(rel);
        if (file.Exists) { return file.FullName; }

        return rel;
    }
}